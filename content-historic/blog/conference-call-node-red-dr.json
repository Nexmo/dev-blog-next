{"_filedata":{"slug":"conference-call-node-red-dr"},"title":"Build a Conference Call with Node-RED","description":"","thumbnail":"https://www.nexmo.com/wp-content/uploads/2019/10/conference-call-node-red-featured.png","author":256,"published":true,"published_at":"2019-10-07T21:52:57","tags":[679,1631,1632,1540,1557,1625,1630,1629,1634,1633,595],"body":"In [previous tutorials](https://www.nexmo.com/blog/tag/node-red) you’ve had a chance to get your feet wet in the world of Nexmo APIs, making and receiving phone calls using the [Voice API](https://developer.nexmo.com/voice/voice-api/overview), and hopefully also customizing these experiences.\n\nIn today’s tutorial, we’ll take it a step further and build a voice-based conferencing service.\n\nThe user calls a predefined virtual number and inputs a meeting ID using the dial pad, then they get placed in the same conference call with everyone else who has provided the same ID.\n\nSteps:  \n1\\. Prerequisites  \n2\\. Expose Your Local Server to the Internet  \n3\\. Define the Webhook Endpoint for Inbound Calls  \n4\\. Define the Webhook Endpoint for the Input Event  \n5\\. Create a Nexmo Voice Application  \n6\\. Set Up a Number to Call  \n7\\. Handle Your Call Events  \n8\\. Try it out!\n\n## Prerequisites\n\nBefore getting started, you’ll need a few things:\n\n*   [Node.js](https://nodejs.org/en/) and [Node-RED](https://nodered.org/docs/getting-started/installation) installed on your machine\n*   A Nexmo account—[create one for free](https://dashboard.nexmo.com/sign-up) if you haven’t already\n*   A way to expose your server to the internet. This either means you’re running a hosted version of Node-RED, or in case you’re developing locally, using a tunneling service like [ngrok](https://ngrok.com/download)—get up to speed with this [Getting Started with Ngrok in Node-RED](https://www.nexmo.com/blog/2019/07/03/ngrok-in-node-red-dr/) tutorial\n\n### Getting Your Credentials\n\nTo interact with the Voice API, you’ll need to make note of a couple of things. Once you’ve created a Nexmo account, go to the [dashboard](https://dashboard.nexmo.com) to find your API key and secret.\n\nNext, you’ll need a _Voice-enabled_ virtual number. Go to Numbers > [Buy numbers](https://dashboard.nexmo.com/buy-numbers) to get one.\n\n![](https://www.nexmo.com/wp-content/uploads/2019/04/buy-number-nexmo-dashboard.gif)\n\n### Setting Up Your Node-RED Editor\n\nFirst, you’ll need to [install](https://nodered.org/docs/getting-started/installation) the runtime and editor. This could be done either on your local machine, on a Single Board Computer (eg. Raspberry Pi), or through several cloud-hosted options. This example will be using your local machine, so once you’ve installed Node-RED globally, type the command below in your terminal to get started.\n\n<textarea wrap=\"soft\" class=\"crayon-plain print-no\" data-settings=\"dblclick\" readonly=\"\" style=\"-moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4; font-size: 14px !important; line-height: 22px !important;\">$ node-red</textarea>\n\n<table class=\"crayon-table\"><tbody><tr class=\"crayon-row\"><td class=\"crayon-nums \" data-settings=\"show\"><div class=\"crayon-nums-content\" style=\"font-size: 14px !important; line-height: 22px !important;\"><div class=\"crayon-num\" data-line=\"crayon-5e9ddc1ff31de609378911-1\">1</div><div class=\"crayon-num crayon-striped-num\" data-line=\"crayon-5e9ddc1ff31de609378911-2\">2</div></div></td><td class=\"crayon-code\"><div class=\"crayon-pre\" style=\"font-size: 14px !important; line-height: 22px !important; -moz-tab-size:4; -o-tab-size:4; -webkit-tab-size:4; tab-size:4;\"><div class=\"crayon-line\" id=\"crayon-5e9ddc1ff31de609378911-1\"><span class=\"crayon-sy\">$</span><span class=\"crayon-h\"> </span><span class=\"crayon-v\">node</span><span class=\"crayon-o\">-</span><span class=\"crayon-i\">red</span></div><div class=\"crayon-line crayon-striped-line\" id=\"crayon-5e9ddc1ff31de609378911-2\">&nbsp;</div></div></td></tr></tbody></table>\n\nYou can then access the Node-RED editor by pointing your browser at [http://localhost:1880](http://localhost:1880).\n\nOnce you have your editor open, you’ll need to install the Nexmo nodes. You can do so under the _Manage palette_ menu, by searching for the `node-red-contrib-nexmo` package and clicking install.\n\nNow you should see all of the Nexmo nodes appear on the left side of your screen—in your node palette, among other default nodes.\n\n## Expose Your Local Server to the Internet\n\nThe Nexmo API will need access to your webhooks to make calls against them, so let’s [make them accessible over the public internet](https://www.nexmo.com/blog/2019/07/03/ngrok-in-node-red-dr/). If you’re running Node-RED on a public web server instead of your local machine, you’re all set and ready to move on to the [_Create a Nexmo Voice Application_](link_me) step.\n\nOtherwise, a convenient way to do this is by using a tunneling service like [ngrok](https://ngrok.com).\n\nFirst, you’ll need to install the ngrok node. To do so, open up _Manage palette_ from the hamburger menu in your Node-RED editor, search for the `node-red-contrib-ngrok` package, and click install. After restarting your editor, the _`ngrok`_ node should appear in the node palette.\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/ngrok-manage-palette.png)\n\nThe `ngrok` node takes the strings _on_ or _off_ as input to start/stop the tunnel, and outputs the ngrok host address as the `msg.payload`.\n\nThe easiest way to set this up is to wire two `inject` nodes as the `ngrok` node’s input, one with the payload of the string _on_ and the other with _off_. For easier use, you could also set the `Name` of these nodes accordingly in the node properties, so that it’s clear what functionality they have. Next, to display the host address in the debug sidebar, connect a `debug` node after `ngrok`.\n\nAs the last step before hitting _Deploy_, open up the `ngrok` node properties and specify the port number. In case of Node-RED, the default value is `1880`. The default ngrok Region is US but you can also set it to Europe or Asia. You can also add your authtoken for your ngrok account if you have one. Don’t worry if you don’t, just skip this step for now. The node will warn that it is not fully configured but this is not an issue.\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/ngrok-node-properties.png)\n\nAnd you’re all set! Once you hit **Deploy** and click on the **on** `inject` node’s button, navigate to the URL displayed in the debug area (YOUR\\_URL for future reference) to find your Node-RED editor at a public address.\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/ngrok-nodered.png)\n\n## Define the Webhook Endpoint for Inbound Calls\n\nNexmo calls are controlled using _Nexmo Call Control Objects_, also known as NCCOs. An NCCO defines a list of actions to be followed when a call is handled. There are lots of different actions available; find the corresponding nodes under the Nexmo palette in your Node-RED editor or check out the [NCCO Reference](https://developer.nexmo.com/api/voice/ncco) to find out more about them.\n\nWhen handling inbound calls, you need your NCCO hosted at an _Answer URL_. In this case, we’ll be using a `talk` action to ask tor the meeting ID, then an `input` action to collect it.\n\nAdd a _`voice webhook`_ input node to your canvas, followed by a _`talk`_ node, an _`input`_ node and a _`return NCCO`_ output node.\n\nNext, in the _`voice webhook`_ node, select `GET` as a `Method` and type `/answer` in the answer URL field.\n\nIn the _`talk`_ node properties set the `Text{}` field to the message you’d like to be read out when the call is answered. E.g. “Please enter the meeting ID”. You can also select a `Voice Name`, see the [Text to Speech Guide](https://developer.nexmo.com/voice/voice-api/guides/text-to-speech#voice-names) for the full list of options.\n\nFinally open the _`input`_ node editor, set `YOUR_URL/input` as the `URL {}` and `POST` as a `Method`.\n\nAt this time you could also set a couple of other parameters to further customize the experience:\n\n| Name | Description |\n| --- | --- |\n| `Submit On Hash`: | Set to true so the caller’s activity is sent to your webhook endpoint at `YOUR_URL/input` after they press `#`. If `#` is not pressed the result is submitted after `Time Out` seconds. The default value is false. |\n| `Time Out`: | The result of the caller’s activity is sent to the `YOUR_URL/input` webhook endpoint `Time Out` seconds after the last action. The default value is 3. Max is 10. |\n| `Max Digits`: | The number of digits the user can press. The maximum value is 20, the default is 4 digits. |\n\nFind out more about these in the [NCCO Reference](https://developer.nexmo.com/voice/voice-api/ncco-reference#input).\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/conference-answer-url.gif)\n\n## Define the Webhook Endpoint for the Input Event\n\nYou’ll also need a second endpoint to capture the DTMF input from the user, and based on the code they have submitted, place them into a _conversation_.\n\nAdd another _`voice webhook`_ input node to your canvas, followed by a _`talk`_ node, a _`conversation`_ node and a _`return NCCO`_ output node.\n\n#### `voice webhook`\n\nIn the _`voice webhook`_ node properties, select `POST` as a method and type `/input` in the answer URL field.\n\nIf you were to connect a `debug` node after it, after finishing and running the flow, you would see the parameters returned to the `/input` URL:\n\n| Name | Description |\n| --- | --- |\n| `uuid` | The unique ID of the Call leg for the user initiating the input. |\n| `conversation_uuid` | The unique ID for this conversation. |\n| `timed_out` | Returns true if this input timed out based on the value of `Time Out`. |\n| `dtmf` | The numbers input by your caller, in order. |\n\nIn our use case, we are trying to get the `dtmf` value, as this is the meeting ID provided by the caller.\n\nHaving a closer look at the debug sidebar on completions, we can see that it’s going to be in the `dtmf` property of the `call` object nested inside the `msg` object, so we can reference it as `{{msg.call.dtmf}}` in the other nodes of this path.\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/dtmf-debug.png)\n\n#### `talk`\n\nNext, open up the _`talk`_ node editor and set the `Text{}` field to the message you’d like to be read out once the caller inputs the meeting ID.\n\nNote the `{}` sign next to the `Text` label, showing that this value can be set dynamically, using [Mustache templating](https://mustache.github.io/), so you could go with something like `Joining meeting {{msg.call.dtmf}}`.\n\nFeel free to further personalize the experience by selecting a [`Voice Name`](https://developer.nexmo.com/voice/voice-api/guides/text-to-speech#voice-names) or by making use of [SSML tags](https://developer.nexmo.com/voice/voice-api/guides/customizing-tts)\n\n#### `conversation`\n\nWe’re using the _`conversation`_ action to create a standard conference, so the only parameter we have to set is `Name {}`. Using the conversation action with the same name reuses the same persisted Conversation, so it’s handy to name it after the meeting ID, referencing `{{msg.call.dtmf}}` The first person to call the virtual number assigned to the conversation creates it.\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/conference-conversation-node.png)\n\nIn the future, you might want to take this a step further and create a moderated Conversation with selective audio controls. Check out the [NCCO reference](https://developer.nexmo.com/voice/voice-api/ncco-reference#conversation) to find out more.\n\nOnce you’re done with this path, it should look similar to this:\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/conference-input-url.gif)\n\n## Create a Nexmo Voice Application\n\nSome of Nexmo’s APIs, including the Voice API, use Nexmo Applications to hold security and config information needed to connect to Nexmo endpoints.\n\nIn the Nexmo Node-RED palette, several nodes have the capability to create these applications: _`getrecording`_, _`earmuff`_, _`mute`_, _`hangup`_, _`transfer`_, _`createcall`_, _`playaudio`_, _`playtts`_ and _`playdtmf`_.\n\nDrag any of these nodes into your workspace, then double-click on it to open up the node properties.\n\nNext to the `Nexmo Credentials`, select “Add new nexmovoiceapp…” from the drop-down menu and click the edit button. Fill in the details below and click `Create New Application`.\n\n| KEY | DESCRIPTION |\n| --- | --- |\n| `Name` | Choose a name for your Voice Application, for example `Conference Call`. |\n| `API Key` | Your Nexmo API key, shown in your [account overview](https://dashboard.nexmo.com/getting-started-guide). |\n| `API Secret` | Your Nexmo API secret, shown in your [account overview](https://dashboard.nexmo.com/getting-started-guide). |\n| `Answer URL` | YOUR\\_URL/answer, you’ll be hosting a Nexmo Call Control Object (NCCO) here. – more about this later on. |\n| `Event URL` | YOUR\\_URL/event, you’ll need to reference this when setting up the event handler. |\n\nNode-RED will then create a new Nexmo Application on your account and fill in the App ID and Private Key fields for you to save. After this step, feel free to delete the Nexmo node you used, as a `nexmovoiceapp` config node has been created, and that contains all the Nexmo credentials this flow needs.\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/conference-create-voiceapp.png)\n\n## Set Up a Number to Call\n\nNext, you’ll have to link your virtual number to this application.\n\nFind the Voice Application you’ve just created in your Nexmo Dashboard by navigating to _Voice_ > _[Your Applications](https://dashboard.nexmo.com/voice/your-applications)_.\n\nClick on the name of this application, then under the _Numbers_ tab click on the **Link** button next to the virtual number you’ve rented earlier.\n\nIn case the number you’d like to use is already linked to another app, click on **Manage number** and configure it to forward incoming calls to your app.\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/congerence-link-number.png)\n\n_Bonus tip:_ Use a _`comment`_ node to take note of the Nexmo number linked to your application, this way you always have it handy.\n\n## Handle Your Call Events\n\nIf you’d like to receive events about the progress of your call, you can also set up an event webhook.\n\nConnect an `http` input node to an `http response` node, as well as to a `debug` node, so that you can view your call events in the debug area.\n\nIn the `http` input node, select `POST` as a `Method` and fill in the `URL` field with `/event`.\n\nThe `http response` node should have `200` set as `Status code`, but don’t worry about it; this is the default value as well.\n\n![](https://www.nexmo.com/wp-content/uploads/2019/10/conference-final-flow.png)\n\n## Try it Out!\n\nAnd that’s a wrap! Get a friend or more and take it for a spin! Don’t forget to take a peek in the debug area to follow your call events. Enjoy!\n\n## Where Next?\n\n### Resources:\n\n*   [Conversation NCCO Reference](https://developer.nexmo.com/voice/voice-api/ncco-reference#conversation)\n*   [Input NCCO Reference](https://developer.nexmo.com/voice/voice-api/ncco-reference#input)\n*   [Get Started with ngrok in Node-RED](https://www.nexmo.com/blog/2019/07/03/ngrok-in-node-red-dr/)\n*   [Voice API Reference](https://developer.nexmo.com/voice/voice-api/overview)\n\n### Try another tutorial:\n\n*   [Verify Phone Numbers with Node-RED](https://www.nexmo.com/blog/2019/09/25/verify-phone-numbers-with-node-red-dr)\n*   [How to Stream Audio into a Call with Node-RED](https://www.nexmo.com/blog/2019/07/15/stream-audio-node-red-dr)\n*   [How to Make Text-to-Speech Phone Calls with Node-RED](https://www.nexmo.com/blog/2019/06/14/make-text-to-speech-phone-calls-node-red-dr/)\n*   [How to Receive Phone Calls with Node-RED](https://www.nexmo.com/blog/2019/05/09/receive-phone-calls-node-red-dr/)\n*   [How to Send SMS Messages with Node-RED](https://www.nexmo.com/blog/2019/04/17/send-sms-messages-node-red-dr/)\n*   [How to Receive SMS Messages with Node-RED](https://www.nexmo.com/blog/2019/04/24/receive-sms-messages-node-red-dr/)\n\nwindow.addEventListener('DOMContentLoaded', (event) => { document.querySelectorAll(\".gif-player\").forEach(image => { image.src = image.src.replace(/\\\\.gif$/g, \".png\") image.addEventListener(\"click\", (event) => { if (event.target.src.indexOf(\".gif\") > 0) { image.src = image.src.replace(/\\\\.gif$/g, \".png\") } else { image.src = image.src.replace(/\\\\.png$/g, \".gif\") } }) }) });\n\n.gif-player { cursor: pointer; } img.alignnone { border-width: 0px !important; }"}